  Application.cpp
  CommandList.cpp
  Device.cpp
  Game.cpp
  HighResolutionClock.cpp
  Lesson3.cpp
  Mesh.cpp
  RenderTarget.cpp
  Texture.cpp
C:\Code\DX12New\DX12New\DescriptorAllocator.h(29,55): warning C4099: “std::default_delete<DescriptorAllocator>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Application.cpp)
C:\Code\DX12New\DX12New\DescriptorAllocator.h(29): message : 参见“std::default_delete<DescriptorAllocator>”的声明 (编译源文件 Application.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29,50): warning C4099: “std::default_delete<dx12lib::RootSignature>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Device.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29): message : 参见“std::default_delete<dx12lib::RootSignature>”的声明 (编译源文件 Device.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29,50): warning C4099: “std::default_delete<dx12lib::RootSignature>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 RenderTarget.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29): message : 参见“std::default_delete<dx12lib::RootSignature>”的声明 (编译源文件 RenderTarget.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29,50): warning C4099: “std::default_delete<dx12lib::RootSignature>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 CommandList.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29): message : 参见“std::default_delete<dx12lib::RootSignature>”的声明 (编译源文件 CommandList.cpp)
C:\Code\DX12New\DX12New\CommandQueue.h(38,48): warning C4099: “std::default_delete<CommandQueue>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Application.cpp)
C:\Code\DX12New\DX12New\CommandQueue.h(38): message : 参见“std::default_delete<CommandQueue>”的声明 (编译源文件 Application.cpp)
C:\Code\DX12New\DX12New\CommandQueue.h(38,48): warning C4099: “std::default_delete<CommandQueue>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 CommandList.cpp)
C:\Code\DX12New\DX12New\CommandQueue.h(38): message : 参见“std::default_delete<CommandQueue>”的声明 (编译源文件 CommandList.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29,50): warning C4099: “std::default_delete<dx12lib::RootSignature>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Application.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29): message : 参见“std::default_delete<dx12lib::RootSignature>”的声明 (编译源文件 Application.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29,50): warning C4099: “std::default_delete<dx12lib::RootSignature>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29): message : 参见“std::default_delete<dx12lib::RootSignature>”的声明 (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29,50): warning C4099: “std::default_delete<dx12lib::RootSignature>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Texture.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29): message : 参见“std::default_delete<dx12lib::RootSignature>”的声明 (编译源文件 Texture.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29,50): warning C4099: “std::default_delete<dx12lib::RootSignature>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Mesh.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29): message : 参见“std::default_delete<dx12lib::RootSignature>”的声明 (编译源文件 Mesh.cpp)
C:\Code\DX12New\DX12New\Texture.cpp(141,107): error C2660: “ID3D12Device::CreateUnorderedAccessView”: 函数不接受 3 个参数
C:\Program Files (x86)\Windows Kits\10\Include\10.0.22000.0\um\d3d12.h(8464,40): message : 参见“ID3D12Device::CreateUnorderedAccessView”的声明 (编译源文件 Texture.cpp)
C:\Code\DX12New\DX12New\Texture.cpp(148,38): error C2039: "GetShaderResourceView": 不是 "Texture" 的成员
C:\Code\DX12New\DX12New\Texture.h(12): message : 参见“Texture”的声明
C:\Code\DX12New\DX12New\Texture.cpp(149,1): error C2270: “GetShaderResourceView”: 非成员函数上不允许修饰符
C:\Code\DX12New\DX12New\Texture.cpp(150,9): error C2065: “m_ShaderResourceView”: 未声明的标识符
C:\Code\DX12New\DX12New\Texture.cpp(153,38): error C2039: "GetUnorderedAccessView": 不是 "Texture" 的成员
C:\Code\DX12New\DX12New\Texture.h(12): message : 参见“Texture”的声明
C:\Code\DX12New\DX12New\Texture.cpp(154,1): error C2270: “GetUnorderedAccessView”: 非成员函数上不允许修饰符
C:\Code\DX12New\DX12New\Texture.cpp(155,9): error C2065: “m_UnorderAccessView”: 未声明的标识符
C:\Code\DX12New\DX12New\RootSignature.h(29,50): warning C4099: “std::default_delete<dx12lib::RootSignature>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Game.cpp)
C:\Code\DX12New\DX12New\RootSignature.h(29): message : 参见“std::default_delete<dx12lib::RootSignature>”的声明 (编译源文件 Game.cpp)
C:\Code\DX12New\DX12New\CommandQueue.h(38,48): warning C4099: “std::default_delete<CommandQueue>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\CommandQueue.h(38): message : 参见“std::default_delete<CommandQueue>”的声明 (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\Material.h(37,1): warning C4099: “Material”: 类型名称以前使用“class”现在使用的是“struct” (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\Material.h(36): message : 参见“Material”的声明 (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\DescriptorAllocator.h(29,55): warning C4099: “std::default_delete<DescriptorAllocator>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Device.cpp)
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\memory(1231): message : 参见“std::default_delete<DescriptorAllocator>”的声明 (编译源文件 Device.cpp)
C:\Code\DX12New\DX12New\Game.cpp(29,13): error C2039: "RegisterCallBacks": 不是 "Window" 的成员
C:\Code\DX12New\DX12New\Window.h(21): message : 参见“Window”的声明
C:\Code\DX12New\DX12New\Mesh.cpp(89,70): error C2664: “void CommandList::SetVertexBuffer(uint32_t,const VertexBuffer &)”: 无法将参数 2 从“_Ty2”转换为“const VertexBuffer &”
          with
          [
              _Ty2=std::shared_ptr<VertexBuffer>
          ]
C:\Code\DX12New\DX12New\Mesh.cpp(89,70): message : 原因如下: 无法从“_Ty2”转换为“const VertexBuffer”
          with
          [
              _Ty2=std::shared_ptr<VertexBuffer>
          ]
C:\Code\DX12New\DX12New\Mesh.cpp(89,63): message : 没有可用于执行该转换的用户定义的转换运算符，或者无法调用该运算符
C:\Code\DX12New\DX12New\CommandList.h(160,7): message : 参见“CommandList::SetVertexBuffer”的声明 (编译源文件 Mesh.cpp)
C:\Code\DX12New\DX12New\Mesh.cpp(97,43): error C2664: “void CommandList::SetIndexBuffer(const IndexBuffer &)”: 无法将参数 1 从“std::shared_ptr<IndexBuffer>”转换为“const IndexBuffer &”
C:\Code\DX12New\DX12New\Mesh.cpp(97,43): message : 原因如下: 无法从“std::shared_ptr<IndexBuffer>”转换为“const IndexBuffer”
C:\Code\DX12New\DX12New\Mesh.cpp(97,30): message : 没有可用于执行该转换的用户定义的转换运算符，或者无法调用该运算符
C:\Code\DX12New\DX12New\CommandList.h(170,7): message : 参见“CommandList::SetIndexBuffer”的声明 (编译源文件 Mesh.cpp)
C:\Code\DX12New\DX12New\Mesh.cpp(98,75): warning C4267: “参数”: 从“size_t”转换到“uint32_t”，可能丢失数据
C:\Code\DX12New\DX12New\Mesh.cpp(102,65): warning C4267: “参数”: 从“size_t”转换到“uint32_t”，可能丢失数据
C:\Code\DX12New\DX12New\CommandQueue.h(38,48): warning C4099: “std::default_delete<CommandQueue>”: 类型名称以前使用“struct”现在使用的是“class” (编译源文件 Device.cpp)
C:\Code\DX12New\DX12New\CommandQueue.h(38): message : 参见“std::default_delete<CommandQueue>”的声明 (编译源文件 Device.cpp)
C:\Code\DX12New\DX12New\RenderTarget.cpp(12,31): error C2280: “Texture &Texture::operator =(const Texture &)”: 尝试引用已删除的函数
C:\Code\DX12New\DX12New\Texture.h(92): message : 编译器已在此处生成“Texture::operator =”
C:\Code\DX12New\DX12New\Texture.h(92,1): message : “Texture &Texture::operator =(const Texture &)”: 由于 基类 调用已删除或不可访问的函数“Resource &Resource::operator =(const Resource &)”，因此已隐式删除函数 (编译源文件 RenderTarget.cpp)
C:\Code\DX12New\DX12New\Resource.h(55,1): message : “Resource &Resource::operator =(const Resource &)”: 由于“Resource”具有引用类型的数据成员“Resource::m_Device”，因此已隐式删除函数 (编译源文件 RenderTarget.cpp)
C:\Code\DX12New\DX12New\Resource.h(50): message : 参见“Resource::m_Device”的声明 (编译源文件 RenderTarget.cpp)
C:\Code\DX12New\DX12New\CommandList.cpp(189,12): error C2039: "SetResource": 不是 "Texture" 的成员
C:\Code\DX12New\DX12New\Texture.h(12): message : 参见“Texture”的声明
C:\Code\DX12New\DX12New\CommandList.cpp(257,12): error C2039: "SetResource": 不是 "Texture" 的成员
C:\Code\DX12New\DX12New\Texture.h(12): message : 参见“Texture”的声明
C:\Code\DX12New\DX12New\CommandList.cpp(458,51): error C2664: “Texture::Texture(Device &,Microsoft::WRL::ComPtr<ID3D12Resource>,const D3D12_CLEAR_VALUE *)”: 无法将参数 1 从“Microsoft::WRL::ComPtr<ID3D12Resource>”转换为“Device &”
C:\Code\DX12New\DX12New\Texture.h(80,5): message : 参见“Texture::Texture”的声明 (编译源文件 CommandList.cpp)
C:\Code\DX12New\DX12New\CommandList.cpp(502,40): error C2664: “Texture::Texture(const Texture &)”: 无法将参数 1 从“Microsoft::WRL::ComPtr<ID3D12Resource>”转换为“const Texture &”
C:\Code\DX12New\DX12New\CommandList.cpp(502,40): message : 原因如下: 无法从“Microsoft::WRL::ComPtr<ID3D12Resource>”转换为“const Texture”
C:\Code\DX12New\DX12New\CommandList.cpp(502,25): message : 没有可用于执行该转换的用户定义的转换运算符，或者无法调用该运算符
C:\Code\DX12New\DX12New\Texture.h(92,1): message : 参见“Texture::Texture”的声明 (编译源文件 CommandList.cpp)
C:\Code\DX12New\DX12New\CommandList.cpp(525,18): error C2039: "SetResource": 不是 "Texture" 的成员
C:\Code\DX12New\DX12New\Texture.h(12): message : 参见“Texture”的声明
C:\Code\DX12New\DX12New\CommandList.cpp(614,96): warning C4267: “参数”: 从“size_t”转换到“UINT”，可能丢失数据
C:\Code\DX12New\DX12New\CommandList.cpp(619,95): warning C4267: “参数”: 从“size_t”转换到“UINT”，可能丢失数据
C:\Code\DX12New\DX12New\CommandList.cpp(785,136): error C2039: "GetShaderResourceView": 不是 "Resource" 的成员
C:\Code\DX12New\DX12New\ResourceStateTracker.h(10): message : 参见“Resource”的声明
C:\Code\DX12New\DX12New\CommandList.cpp(785,163): error C2660: “DynamicDescriptorHeap::StageDescriptor”: 函数不接受 3 个参数
C:\Code\DX12New\DX12New\DynamicDescriptorHeap.h(27,7): message : 参见“DynamicDescriptorHeap::StageDescriptor”的声明 (编译源文件 CommandList.cpp)
C:\Code\DX12New\DX12New\CommandList.cpp(813,136): error C2039: "GetUnorderedAccessView": 不是 "Resource" 的成员
C:\Code\DX12New\DX12New\ResourceStateTracker.h(10): message : 参见“Resource”的声明
C:\Code\DX12New\DX12New\CommandList.cpp(813,164): error C2660: “DynamicDescriptorHeap::StageDescriptor”: 函数不接受 3 个参数
C:\Code\DX12New\DX12New\DynamicDescriptorHeap.h(27,7): message : 参见“DynamicDescriptorHeap::StageDescriptor”的声明 (编译源文件 CommandList.cpp)
C:\Code\DX12New\DX12New\CommandList.cpp(1124,10): error C2039: "SetResource": 不是 "Buffer" 的成员
C:\Code\DX12New\DX12New\Buffer.h(7): message : 参见“Buffer”的声明
C:\Code\DX12New\DX12New\Application.cpp(44,23): error C2039: "MouseButton": 不是 "MouseButtonEventArgs" 的成员
C:\Code\DX12New\DX12New\Event.h(245): message : 参见“MouseButtonEventArgs”的声明
C:\Code\DX12New\DX12New\Application.cpp(46,24): error C2039: "MouseButton": 不是 "MouseButtonEventArgs" 的成员
C:\Code\DX12New\DX12New\Event.h(245): message : 参见“MouseButtonEventArgs”的声明
C:\Code\DX12New\DX12New\Application.cpp(46,72): error C2039: "None": 不是 "MouseButtonEventArgs" 的成员
C:\Code\DX12New\DX12New\Event.h(245): message : 参见“MouseButtonEventArgs”的声明
C:\Code\DX12New\DX12New\Application.cpp(46,76): error C2065: “None”: 未声明的标识符
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory(723,1): error C2248: “Texture::~Texture”: 无法访问 protected 成员(在“Texture”类中声明) (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\Texture.h(92): message : 编译器已在此处生成“Texture::~Texture” (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\CommandList.h(25): message : 参见“Texture”的声明 (编译源文件 Lesson3.cpp)
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory(950): message : 查看对正在编译的函数 模板 实例化“void std::_Default_allocator_traits<_Alloc>::destroy<_Ty>(_Alloc &,_Uty *const )”的引用
          with
          [
              _Alloc=std::allocator<Texture>,
              _Ty=Texture,
              _Uty=Texture
          ] (编译源文件 Lesson3.cpp)
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory(950): message : 查看对正在编译的函数 模板 实例化“void std::_Default_allocator_traits<_Alloc>::destroy<_Ty>(_Alloc &,_Uty *const )”的引用
          with
          [
              _Alloc=std::allocator<Texture>,
              _Ty=Texture,
              _Uty=Texture
          ] (编译源文件 Lesson3.cpp)
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector(1680): message : 查看对正在编译的函数 模板 实例化“void std::_Destroy_range<std::allocator<Texture>>(Texture *,Texture *const ,_Alloc &) noexcept”的引用
          with
          [
              _Alloc=std::allocator<Texture>
          ] (编译源文件 Lesson3.cpp)
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector(1678): message : 在编译 类 模板 成员函数“void std::vector<Texture,std::allocator<Texture>>::_Destroy(Texture *,Texture *)”时 (编译源文件 Lesson3.cpp)
C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector(1764): message : 查看对正在编译的函数 模板 实例化“void std::vector<Texture,std::allocator<Texture>>::_Destroy(Texture *,Texture *)”的引用 (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\RenderTarget.h(54): message : 查看对正在编译的 类 模板 实例化“std::vector<Texture,std::allocator<Texture>>”的引用 (编译源文件 Lesson3.cpp)
C:\Code\DX12New\DX12New\Device.cpp(139): error C4716: “Device::CreateByteAddressBuffer”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(144): error C4716: “Device::CreateStructuredBuffer”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(149): error C4716: “Device::CreateStructuredBuffer”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(154): error C4716: “Device::CreateTexture”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(159): error C4716: “Device::CreateTexture”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(164): error C4716: “Device::CreateIndexBuffer”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(169): error C4716: “Device::CreateIndexBuffer”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(179): error C4716: “Device::CreateVertexBuffer”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(184): error C4716: “Device::CreateRootSignature”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(174): error C4716: “Device::CreateVertexBuffer”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(189): error C4716: “Device::CreateConstantBufferView”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(194): error C4716: “Device::CreateShaderResourceView”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(201): error C4716: “Device::CreateUnorderedAccessView”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(245): error C4716: “Device::GetMultisampleQualityLevels”: 必须返回一个值
C:\Code\DX12New\DX12New\Device.cpp(319): error C4716: “Device::DoCreatePipelineStateObject”: 必须返回一个值
